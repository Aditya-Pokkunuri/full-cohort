-- Cohort Organization Assessment Setup Script
-- Run this in your NEW Supabase Project SQL Editor

-- 1. Organizations
create table if not exists public.organizations (
  id uuid default gen_random_uuid() primary key,
  name text not null,
  created_at timestamptz default now()
);

alter table public.organizations enable row level security;
create policy "Public read organizations" on public.organizations for select using (true);

-- 2. Profiles (Extends auth.users)
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade primary key,
  email text,
  full_name text,
  role text check (role in ('executive', 'manager', 'team_lead', 'employee')),
  avatar_url text,
  org_id uuid references public.organizations(id),
  is_hidden boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.profiles enable row level security;
create policy "Users can read all profiles in their org" on public.profiles
  for select using (true); -- Simplified for assessment

create policy "Users can update own profile" on public.profiles
  for update using (auth.uid() = id);

create policy "Admins can insert profiles" on public.profiles
  for insert with check (true);

-- 3. Projects
create table if not exists public.projects (
  id bigint generated by default as identity primary key,
  name text not null,
  description text,
  status text default 'active',
  org_id uuid references public.organizations(id),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.projects enable row level security;
create policy "Users can view projects in their org" on public.projects
  for select using (org_id = (select org_id from profiles where id = auth.uid()));

-- 4. Project Members
create table if not exists public.project_members (
  id bigint generated by default as identity primary key,
  project_id bigint references public.projects(id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  role text default 'member',
  org_id uuid references public.organizations(id),
  created_at timestamptz default now()
);

alter table public.project_members enable row level security;
create policy "Users can view project members" on public.project_members
  for select using (org_id = (select org_id from profiles where id = auth.uid()));

-- 5. Tasks
create table if not exists public.tasks (
  id bigint generated by default as identity primary key,
  title text not null,
  description text,
  status text default 'pending',
  priority text default 'medium',
  allocated_hours numeric,
  start_date date,
  due_date date,
  due_time time,
  assigned_to uuid references public.profiles(id),
  assigned_by uuid references public.profiles(id),
  project_id bigint references public.projects(id),
  org_id uuid references public.organizations(id),
  phase_validations jsonb default '{}'::jsonb,
  lifecycle_state text default 'requirements',
  sub_state text default 'in_progress',
  issues text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.tasks enable row level security;
create policy "Users can view tasks in their org" on public.tasks
  for select using (org_id = (select org_id from profiles where id = auth.uid()));
create policy "Users can update tasks" on public.tasks
  for all using (org_id = (select org_id from profiles where id = auth.uid()));

-- 6. Messaging & Notifications
create table if not exists public.conversations (
  id text primary key default gen_random_uuid()::text, -- Using text ID to support 'temp_' IDs if needed
  type text check (type in ('dm', 'team', 'everyone')),
  name text,
  org_id uuid references public.organizations(id),
  created_at timestamptz default now()
);
alter table public.conversations enable row level security;
create policy "View conversations" on public.conversations for select using (true);
create policy "Insert conversations" on public.conversations for insert with check (true);

create table if not exists public.conversation_members (
  id bigint generated by default as identity primary key,
  conversation_id text references public.conversations(id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  joined_at timestamptz default now()
);
alter table public.conversation_members enable row level security;
create policy "View members" on public.conversation_members for select using (true);
create policy "Insert members" on public.conversation_members for insert with check (true);

create table if not exists public.messages (
  id uuid default gen_random_uuid() primary key,
  conversation_id text references public.conversations(id) on delete cascade,
  sender_user_id uuid references public.profiles(id),
  content text,
  created_at timestamptz default now(),
  is_deleted boolean default false,
  deleted_for uuid[] default array[]::uuid[]
);
alter table public.messages enable row level security;
create policy "View messages" on public.messages for select using (true);
create policy "Insert messages" on public.messages for insert with check (true);

create table if not exists public.conversation_indexes (
  conversation_id text references public.conversations(id) on delete cascade primary key,
  last_message text,
  last_message_at timestamptz,
  updated_at timestamptz default now()
);
alter table public.conversation_indexes enable row level security;
create policy "View indexes" on public.conversation_indexes for select using (true);
create policy "Update indexes" on public.conversation_indexes for all using (true);

create table if not exists public.notifications (
  id bigint generated by default as identity primary key,
  receiver_id uuid references public.profiles(id),
  sender_id uuid references public.profiles(id),
  message text,
  type text,
  is_read boolean default false,
  org_id uuid references public.organizations(id),
  created_at timestamptz default now()
);
alter table public.notifications enable row level security;
create policy "View own notifications" on public.notifications for select using (auth.uid() = receiver_id);
create policy "Insert notifications" on public.notifications for insert with check (true);

create table if not exists public.attachments (
  id uuid default gen_random_uuid() primary key,
  message_id uuid references public.messages(id) on delete cascade,
  file_name text,
  file_type text,
  file_size bigint,
  url text,
  created_at timestamptz default now()
);

-- 7. Seed Data
-- Insert Organization
INSERT INTO public.organizations (id, name)
VALUES ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Cohort')
ON CONFLICT (id) DO NOTHING;

-- NOTE: User Seeding has been moved to a separate Node.js script (seed_users.js)
-- because creating users requires interaction with Supabase Auth (auth.users table),
-- which cannot be done directly via a standard SQL script due to foreign key constraints.

-- Please run `node seed_users.js` after running this SQL script to create:
-- 1 Executive, 5 Managers, 25 Students and their initial data.

-- IMPORTANT NOTE FOR USER:
-- The above script inserts PROFILES. You must still CREATE USERS in the Authentication tab 
-- with the EXACT same Emails and generate new UUIDs, OR (better)
-- Create the users in Auth FIRST, get their IDs, and then update their profiles.
-- actually, the best way is to trigger a profile creation on auth signup.
-- BUT, to make this work "out of the box" for testing, I recommend you:
-- 1. Run this script to create tables and org.
-- 2. Manually Sign Up 'cohort_exec@cohort.test' in the app (or via Supabase dashboard).
-- 3. Manually update the 'role' and 'org_id' of that user in 'profiles' table.
--    UPDATE profiles SET role='executive', org_id='a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11' WHERE email='cohort_exec@cohort.test';

